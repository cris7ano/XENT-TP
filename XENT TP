-- XENT TP LocalScript
-- Place this as a LocalScript under StarterPlayerScripts or StarterGui

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local ProximityPromptService = game:GetService("ProximityPromptService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")

local VALIDATION_URL = "http://127.0.0.1:8080/validate"

local SCRIPT_KEY do
    local ok, env = pcall(function()
        if typeof(getgenv) == "function" then
            return getgenv()
        end
        return _G
    end)

    if ok and type(env) == "table" then
        SCRIPT_KEY = env.SCRIPT_KEY
    else
        SCRIPT_KEY = nil
    end

    if type(SCRIPT_KEY) ~= "string" or SCRIPT_KEY == "" then
        pcall(function()
            local plr = Players.LocalPlayer
            if plr and plr.Kick then
                plr:Kick("Reedem ur key before u execute the script mate")
            end
        end)
        return
    end
end

local function validateScriptKeyOrKick()
    local player = Players.LocalPlayer
    if not player then
        return false
    end

    local payload = {
        key = SCRIPT_KEY,
        roblox_user_id = tostring(player.UserId),
    }

    local ok, result = pcall(function()
        local body = HttpService:JSONEncode(payload)
        return HttpService:PostAsync(VALIDATION_URL, body, Enum.HttpContentType.ApplicationJson, false)
    end)

    if not ok then
        pcall(function()
            player:Kick("Failed to contact license server mate")
        end)
        return false
    end

    local okDecode, data = pcall(function()
        return HttpService:JSONDecode(result)
    end)

    if not okDecode or type(data) ~= "table" then
        pcall(function()
            player:Kick("Invalid response from license server mate")
        end)
        return false
    end

    if not data.ok then
        local msg = tostring(data.message or "License check failed mate")
        pcall(function()
            player:Kick(msg)
        end)
        return false
    end

    return true
end

if not validateScriptKeyOrKick() then
    return
end

local localPlayer = Players.LocalPlayer
local playerGui = localPlayer:WaitForChild("PlayerGui")

-- State
local semiEnabled = false
local savedCFrame: CFrame? = nil
local markerPart: BasePart? = nil
local connections = {}
local activeHolds: {[ProximityPrompt]: boolean} = {}
local promptTriggeredBound: {[ProximityPrompt]: boolean} = {}
local beam: Beam? = nil
local beamFrom: Attachment? = nil
local beamTo: Attachment? = nil

local xrayBeamEnabled = true
local espEnabled = false
local autoGrabEnabled = false
local espHighlights = {}
local espConns = {}

local destroyBeam
local rebuildBeam
local enableESP
local disableESP
local exited = false

local function surfaceGuiHasPlayerName(surfaceGui: SurfaceGui)
	local targetName = localPlayer and localPlayer.Name or nil
	local displayName = localPlayer and localPlayer.DisplayName or nil
	local function matches(text)
		if not text or text == "" then return false end
		local lowerText = string.lower(text)
		if targetName and targetName ~= "" and string.find(lowerText, string.lower(targetName), 1, true) then
			return true
		end
		if displayName and displayName ~= "" and string.find(lowerText, string.lower(displayName), 1, true) then
			return true
		end
		return false
	end
	for _, obj in ipairs(surfaceGui:GetDescendants()) do
		if obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox") then
			if matches(obj.Text) then
				return true
			end
		end
	end
	return false
end

local function updateAllSurfaceGUIs()
	for _, inst in ipairs(workspace:GetDescendants()) do
		if inst:IsA("SurfaceGui") and surfaceGuiHasPlayerName(inst) then
			for _, obj in ipairs(inst:GetDescendants()) do
				if obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox") then
					obj.Text = "discord.gg/QNVb2ukz9a"
					obj.TextColor3 = Color3.fromRGB(0, 200, 255)
					obj.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
					obj.TextStrokeTransparency = 0.1
				end
			end
		end
	end
end

local function addConnection(conn)
	if conn then
		table.insert(connections, conn)
	end
end

local function cleanup()
	if exited then return end
	exited = true

	semiEnabled = false
	savedCFrame = nil
	activeHolds = {}
	promptTriggeredBound = {}

	if beam then
		pcall(function()
			beam:Destroy()
		end)
	end
	beam = nil
	if beamFrom then
		pcall(function()
			beamFrom:Destroy()
		end)
	end
	beamFrom = nil
	if beamTo then
		pcall(function()
			beamTo:Destroy()
		end)
	end
	beamTo = nil

	for _, h in pairs(espHighlights) do
		pcall(function()
			h:Destroy()
		end)
	end
	espHighlights = {}
	for _, c in ipairs(espConns) do
		pcall(function()
			if c.Connected then
				c:Disconnect()
			end
		end)
	end
	espConns = {}
	espEnabled = false

	if markerPart then
		pcall(function()
			markerPart:Destroy()
		end)
		markerPart = nil
	end

	if clearDesyncESP then
		pcall(function()
			clearDesyncESP()
		end)
	end

	for _, conn in ipairs(connections) do
		pcall(function()
			if conn.Connected then
				conn:Disconnect()
			end
		end)
	end
	connections = {}
end

-- UI creation
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "XENT_TP_GUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

updateAllSurfaceGUIs()

local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 260, 0, 150)
mainFrame.Position = UDim2.new(0.5, -130, 0.5, -75)
mainFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 25)
mainFrame.BorderSizePixel = 0
mainFrame.ClipsDescendants = true
mainFrame.Parent = screenGui

local frameCorner = Instance.new("UICorner")
frameCorner.CornerRadius = UDim.new(0, 10)
frameCorner.Parent = mainFrame

local frameStroke = Instance.new("UIStroke")
frameStroke.Thickness = 2.5
frameStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
frameStroke.Color = Color3.fromRGB(95, 120, 255)
frameStroke.Transparency = 0.05
frameStroke.Parent = mainFrame

local frameGradient = Instance.new("UIGradient")
frameGradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(25, 25, 45)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(10, 10, 20))
})
frameGradient.Rotation = 45
frameGradient.Parent = mainFrame

-- Top bar
local topBar = Instance.new("Frame")
topBar.Name = "TopBar"
topBar.Size = UDim2.new(1, 0, 0, 26)
topBar.BackgroundTransparency = 1
topBar.Parent = mainFrame

local titleLabel = Instance.new("TextLabel")
titleLabel.Name = "Title"
titleLabel.BackgroundTransparency = 1
titleLabel.Position = UDim2.new(0, 10, 0, 0)
titleLabel.Size = UDim2.new(0.5, 0, 1, 0)
titleLabel.Font = Enum.Font.GothamBold
titleLabel.Text = "XENT TP"
titleLabel.TextColor3 = Color3.fromRGB(210, 220, 255)
titleLabel.TextXAlignment = Enum.TextXAlignment.Left
titleLabel.TextSize = 16
titleLabel.TextStrokeTransparency = 0.3
titleLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
titleLabel.Parent = topBar

local exitButton = Instance.new("TextButton")
exitButton.Name = "ExitButton"
exitButton.Text = "✕"
exitButton.Font = Enum.Font.GothamBold
exitButton.TextSize = 16
exitButton.Size = UDim2.new(0, 30, 0, 20)
exitButton.Position = UDim2.new(1, -35, 0, 3)
exitButton.BackgroundColor3 = Color3.fromRGB(45, 20, 20)
exitButton.TextColor3 = Color3.fromRGB(255, 120, 120)
exitButton.BorderSizePixel = 0
exitButton.AutoButtonColor = false
exitButton.Parent = topBar

local exitCorner = Instance.new("UICorner")
exitCorner.CornerRadius = UDim.new(0, 6)
exitCorner.Parent = exitButton

local exitStroke = Instance.new("UIStroke")
exitStroke.Color = Color3.fromRGB(255, 120, 120)
exitStroke.Thickness = 2
exitStroke.Transparency = 0.05
exitStroke.Parent = exitButton

local settingsButton = Instance.new("TextButton")
settingsButton.Name = "SettingsButton"
settingsButton.Text = "⚙"
settingsButton.Font = Enum.Font.GothamBold
settingsButton.TextSize = 14
settingsButton.Size = UDim2.new(0, 26, 0, 20)
settingsButton.Position = UDim2.new(1, -70, 0, 3)
settingsButton.BackgroundColor3 = Color3.fromRGB(25, 25, 40)
settingsButton.TextColor3 = Color3.fromRGB(200, 210, 255)
settingsButton.BorderSizePixel = 0
settingsButton.AutoButtonColor = false
settingsButton.Parent = topBar

local settingsCorner = Instance.new("UICorner")
settingsCorner.CornerRadius = UDim.new(0, 6)
settingsCorner.Parent = settingsButton

local settingsStroke = Instance.new("UIStroke")
settingsStroke.Color = Color3.fromRGB(120, 130, 210)
settingsStroke.Thickness = 1.5
settingsStroke.Transparency = 0.1
settingsStroke.Parent = settingsButton

-- Center buttons container
local bodyFrame = Instance.new("Frame")
bodyFrame.Name = "Body"
bodyFrame.BackgroundTransparency = 1
bodyFrame.Size = UDim2.new(1, -20, 1, -40)
bodyFrame.Position = UDim2.new(0, 10, 0, 30)
bodyFrame.Parent = mainFrame

local layout = Instance.new("UIListLayout")
layout.FillDirection = Enum.FillDirection.Vertical
layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
layout.VerticalAlignment = Enum.VerticalAlignment.Center
layout.Padding = UDim.new(0, 8)
layout.Parent = bodyFrame

-- Settings panel
local settingsFrame = Instance.new("Frame")
settingsFrame.Name = "SettingsFrame"
settingsFrame.Size = UDim2.new(1, -20, 0, 80)
settingsFrame.Position = UDim2.new(0, 10, 0, 30)
settingsFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 18)
settingsFrame.Visible = false
settingsFrame.Parent = mainFrame

local settingsCorner2 = Instance.new("UICorner")
settingsCorner2.CornerRadius = UDim.new(0, 8)
settingsCorner2.Parent = settingsFrame

local settingsStroke2 = Instance.new("UIStroke")
settingsStroke2.Color = Color3.fromRGB(80, 90, 160)
settingsStroke2.Thickness = 1.5
settingsStroke2.Transparency = 0.15
settingsStroke2.Parent = settingsFrame

local settingsLayout = Instance.new("UIListLayout")
settingsLayout.FillDirection = Enum.FillDirection.Vertical
settingsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
settingsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
settingsLayout.Padding = UDim.new(0, 6)
settingsLayout.Parent = settingsFrame

local function createSettingsToggleRow(labelText)
	local row = Instance.new("Frame")
	row.Name = labelText .. "_Row"
	row.Size = UDim2.new(1, -10, 0, 24)
	row.BackgroundTransparency = 1
	row.Parent = settingsFrame

	local label = Instance.new("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UDim2.new(0.6, 0, 1, 0)
	label.Position = UDim2.new(0, 0, 0, 0)
	label.Font = Enum.Font.GothamSemibold
	label.TextSize = 13
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.TextColor3 = Color3.fromRGB(230, 235, 255)
	label.TextStrokeTransparency = 0.3
	label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	label.Text = labelText
	label.Parent = row

	local toggle = Instance.new("TextButton")
	toggle.Name = labelText .. "_Toggle"
	toggle.Size = UDim2.new(0, 60, 0, 20)
	toggle.Position = UDim2.new(1, -70, 0.5, -10)
	toggle.BackgroundColor3 = Color3.fromRGB(120, 40, 40)
	toggle.TextColor3 = Color3.fromRGB(230, 235, 255)
	toggle.Font = Enum.Font.GothamBold
	toggle.TextSize = 12
	toggle.Text = "OFF"
	toggle.TextStrokeTransparency = 0.3
	toggle.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	toggle.AutoButtonColor = false
	toggle.BorderSizePixel = 0
	toggle.Parent = row

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = toggle

	local stroke = Instance.new("UIStroke")
	stroke.Thickness = 1.6
	stroke.Color = Color3.fromRGB(230, 150, 150)
	stroke.Transparency = 0.1
	stroke.Parent = toggle

	local function setOn(on)
		if on then
			toggle.Text = "ON"
			toggle.BackgroundColor3 = Color3.fromRGB(60, 160, 90)
			stroke.Color = Color3.fromRGB(150, 230, 170)
		else
			toggle.Text = "OFF"
			toggle.BackgroundColor3 = Color3.fromRGB(120, 40, 40)
			stroke.Color = Color3.fromRGB(230, 150, 150)
		end
	end

	return toggle, setOn
end

local espToggleButton, setEspToggleVisual = createSettingsToggleRow("ESP PLAYERS")
local xrayToggleButton, setXrayToggleVisual = createSettingsToggleRow("XRAY BEAM")
local autoGrabToggleButton, setAutoGrabToggleVisual = createSettingsToggleRow("AUTO GRAB")

local function createButton(name, text)
	local btn = Instance.new("TextButton")
	btn.Name = name
	btn.Size = UDim2.new(0, 150, 0, 34)
	btn.BackgroundColor3 = Color3.fromRGB(50, 50, 70)
	btn.Text = text
	btn.Font = Enum.Font.GothamSemibold
	btn.TextSize = 14
	btn.TextColor3 = Color3.fromRGB(230, 235, 255)
	btn.TextStrokeTransparency = 0.3
	btn.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	btn.AutoButtonColor = false
	btn.BorderSizePixel = 0
	btn.Parent = bodyFrame

	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 8)
	corner.Parent = btn

	local stroke = Instance.new("UIStroke")
	stroke.Thickness = 2
	stroke.Color = Color3.fromRGB(130, 140, 220)
	stroke.Transparency = 0.08
	stroke.Parent = btn

	return btn
end

local semiButton = createButton("SemiTPButton", "SEMI_TP : OFF")
local saveButton = createButton("SavePositionButton", "Save Position")

-- Initial colors for SEMI_TP states
local semiOffColor = Color3.fromRGB(150, 40, 40)
local semiOnColor  = Color3.fromRGB(40, 170, 80)
semiButton.BackgroundColor3 = semiOffColor

local savePurple = Color3.fromRGB(140, 80, 200)
saveButton.BackgroundColor3 = savePurple
local saveStroke = saveButton:FindFirstChildOfClass("UIStroke")
if saveStroke then
	saveStroke.Color = Color3.fromRGB(190, 120, 255)
end

-- Hover animation helper
local function applyHoverEffect(button)
	local baseSize = button.Size
	local baseRotation = 0

	local hoverSize = UDim2.new(baseSize.X.Scale, baseSize.X.Offset + 4, baseSize.Y.Scale, baseSize.Y.Offset + 4)
	local hoverRotation = -10

	local hoverInfo = TweenInfo.new(0.12, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)
	local leaveInfo = TweenInfo.new(0.12, Enum.EasingStyle.Quint, Enum.EasingDirection.Out)

	local hoverTween
	local leaveTween

	addConnection(button.MouseEnter:Connect(function()
		if exited then return end
		if hoverTween then hoverTween:Cancel() end
		leaveTween = nil
		hoverTween = TweenService:Create(button, hoverInfo, {Size = hoverSize, Rotation = hoverRotation})
		hoverTween:Play()
	end))

	addConnection(button.MouseLeave:Connect(function()
		if exited then return end
		if leaveTween then leaveTween:Cancel() end
		hoverTween = nil
		leaveTween = TweenService:Create(button, leaveInfo, {Size = baseSize, Rotation = baseRotation})
		leaveTween:Play()
	end))
end

applyHoverEffect(exitButton)
applyHoverEffect(semiButton)
applyHoverEffect(saveButton)

-- Settings toggle behavior (switch between main body and settings page)
local function toggleSettings()
	if exited then return end
	local showSettings = not settingsFrame.Visible
	settingsFrame.Visible = showSettings
	bodyFrame.Visible = not showSettings
end

settingsButton.MouseButton1Click:Connect(toggleSettings)

-- Settings toggles wiring
setEspToggleVisual(false)
setXrayToggleVisual(true)
setAutoGrabToggleVisual(false)
xrayBeamEnabled = true
espEnabled = false
autoGrabEnabled = false

espToggleButton.MouseButton1Click:Connect(function()
	if exited then return end
	if espEnabled then
		disableESP()
		setEspToggleVisual(false)
	else
		enableESP()
		setEspToggleVisual(true)
	end
end)

autoGrabToggleButton.MouseButton1Click:Connect(function()
	if exited then return end
	autoGrabEnabled = not autoGrabEnabled
	setAutoGrabToggleVisual(autoGrabEnabled)
end)

xrayToggleButton.MouseButton1Click:Connect(function()
	if exited then return end
	xrayBeamEnabled = not xrayBeamEnabled
	setXrayToggleVisual(xrayBeamEnabled)
	if xrayBeamEnabled then
		rebuildBeam()
	else
		destroyBeam()
	end
end)

-- XRAY beam continuous updater
task.spawn(function()
	while not exited do
		if xrayBeamEnabled then
			rebuildBeam()
		end
		task.wait(0.2)
	end
end)

-- Draggable frame (custom)
local dragging = false
local dragStart
local frameStart

local function beginDrag(input)
	dragging = true
	dragStart = input.Position
	frameStart = mainFrame.Position
end

local function updateDrag(input)
	if not dragging then return end
	local delta = input.Position - dragStart
	mainFrame.Position = UDim2.new(
		frameStart.X.Scale,
		frameStart.X.Offset + delta.X,
		frameStart.Y.Scale,
		frameStart.Y.Offset + delta.Y
	)
end

addConnection(mainFrame.InputBegan:Connect(function(input)
	if exited then return end
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		local topBarAbsPos = topBar.AbsolutePosition
		local topBarAbsSize = topBar.AbsoluteSize
		local pos = input.Position
		if pos.X >= topBarAbsPos.X and pos.X <= topBarAbsPos.X + topBarAbsSize.X and
			pos.Y >= topBarAbsPos.Y and pos.Y <= topBarAbsPos.Y + topBarAbsSize.Y then
			beginDrag(input)
		end
	end
end))

addConnection(mainFrame.InputChanged:Connect(function(input)
	if exited then return end
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		if dragging then
			updateDrag(input)
		end
	end
end))

addConnection(UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = false
	end
end))

-- Utility: get character + HRP
local function getCharacterAndHRP()
	local char = localPlayer.Character or localPlayer.CharacterAdded:Wait()
	local hrp = char:FindFirstChild("HumanoidRootPart") :: BasePart
	local humanoid = char:FindFirstChildOfClass("Humanoid")
	if not hrp or not humanoid then
		return nil, nil, nil
	end
	return char, hrp, humanoid
end

-- Beam helpers (XRAY BEAM)
destroyBeam = function()
	if beam then
		pcall(function()
			beam:Destroy()
		end)
	end
	beam = nil
	if beamFrom then
		pcall(function()
			beamFrom:Destroy()
		end)
	end
	beamFrom = nil
	if beamTo then
		pcall(function()
			beamTo:Destroy()
		end)
	end
	beamTo = nil
end

rebuildBeam = function()
	if exited or not xrayBeamEnabled then
		destroyBeam()
		return
	end

	local char, hrp = getCharacterAndHRP()
	if not char or not hrp then
		destroyBeam()
		return
	end

	-- Only draw beam if we have a saved position marker
	if not markerPart or not markerPart.Parent then
		destroyBeam()
		return
	end

	local targetPart: BasePart = markerPart

	-- Rebuild attachments and beam
	destroyBeam()

	beamFrom = Instance.new("Attachment")
	beamFrom.Name = "XENT_BeamFrom"
	beamFrom.Parent = hrp

	beamTo = Instance.new("Attachment")
	beamTo.Name = "XENT_BeamTo"
	beamTo.Parent = targetPart

	beam = Instance.new("Beam")
	beam.Name = "XENT_XRayBeam"
	beam.Attachment0 = beamFrom
	beam.Attachment1 = beamTo
	beam.FaceCamera = true
	beam.Width0 = 0.16
	beam.Width1 = 0.16
	beam.LightEmission = 0.7
	beam.LightInfluence = 0
	beam.Transparency = NumberSequence.new(0)
	beam.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(60, 120, 255)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(20, 40, 140))
	})
	beam.Texture = "rbxassetid://446111271" -- subtle beam texture
	beam.TextureLength = 1
	beam.TextureSpeed = 1
	beam.CurveSize0 = 0
	beam.CurveSize1 = 0
	beam.Parent = workspace
end

-- ESP helpers
local function clearESP()
	for plr, h in pairs(espHighlights) do
		pcall(function()
			h:Destroy()
		end)
	espHighlights[plr] = nil
	end
	for _, c in ipairs(espConns) do
		pcall(function()
			if c.Connected then c:Disconnect() end
		end)
	end
	espConns = {}
end

local function addHighlightForCharacter(plr: Player, char: Model)
	if not char then return end
	local humanoid = char:FindFirstChildOfClass("Humanoid")
	if not humanoid then return end

	if espHighlights[plr] then
		pcall(function()
			espHighlights[plr]:Destroy()
		end)
	end

	local h = Instance.new("Highlight")
	h.Name = "XENT_ESP_Highlight"
	h.FillColor = Color3.fromRGB(80, 180, 255)
	h.FillTransparency = 0.7
	h.OutlineColor = Color3.fromRGB(10, 20, 40)
	h.OutlineTransparency = 0
	h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
	h.Adornee = char
	h.Parent = char

	espHighlights[plr] = h
end

enableESP = function()
	if espEnabled or exited then return end
	espEnabled = true

	clearESP()

	local function trackPlayer(plr: Player)
		if plr == localPlayer then return end
		if not espEnabled then return end
		if plr.Character then
			addHighlightForCharacter(plr, plr.Character)
		end
		local conn = plr.CharacterAdded:Connect(function(char)
			if not espEnabled or exited then return end
			addHighlightForCharacter(plr, char)
		end)
		table.insert(espConns, conn)
	end

	for _, plr in ipairs(Players:GetPlayers()) do
		trackPlayer(plr)
	end

	local addedConn = Players.PlayerAdded:Connect(trackPlayer)
	local removingConn = Players.PlayerRemoving:Connect(function(plr)
		if espHighlights[plr] then
			pcall(function()
				espHighlights[plr]:Destroy()
			end)
			espHighlights[plr] = nil
		end
	end)
	table.insert(espConns, addedConn)
	table.insert(espConns, removingConn)
end

disableESP = function()
	if not espEnabled then return end
	espEnabled = false
	clearESP()
end

-- Desync + special teleport method (Ryxx-style core, no extra GUI/whitelist)
local desyncESPFolder: Folder? = nil
local desyncServerESPPart: BasePart? = nil
local desyncServerConn: RBXScriptConnection? = nil

local desyncFFlags = {
	GameNetPVHeaderRotationalVelocityZeroCutoffExponent = -5000,
	LargeReplicatorWrite5 = true,
	LargeReplicatorEnabled9 = true,
	AngularVelociryLimit = 360,
	TimestepArbiterVelocityCriteriaThresholdTwoDt = 2147483646,
	S2PhysicsSenderRate = 15000,
	DisableDPIScale = true,
	MaxDataPacketPerSend = 2147483647,
	PhysicsSenderMaxBandwidthBps = 20000,
	TimestepArbiterHumanoidLinearVelThreshold = 21,
	MaxMissedWorldStepsRemembered = -2147483648,
	PlayerHumanoidPropertyUpdateRestrict = true,
	SimDefaultHumanoidTimestepMultiplier = 0,
	StreamJobNOUVolumeLengthCap = 2147483647,
	DebugSendDistInSteps = -2147483648,
	GameNetDontSendRedundantNumTimes = 1,
	CheckPVLinearVelocityIntegrateVsDeltaPositionThresholdPercent = 1,
	CheckPVDifferencesForInterpolationMinVelThresholdStudsPerSecHundredth = 1,
	LargeReplicatorSerializeRead3 = true,
	ReplicationFocusNouExtentsSizeCutoffForPauseStuds = 2147483647,
	CheckPVCachedVelThresholdPercent = 10,
	CheckPVDifferencesForInterpolationMinRotVelThresholdRadsPerSecHundredth = 1,
	GameNetDontSendRedundantDeltaPositionMillionth = 1,
	InterpolationFrameVelocityThresholdMillionth = 5,
	StreamJobNOUVolumeCap = 2147483647,
	InterpolationFrameRotVelocityThresholdMillionth = 5,
	CheckPVCachedRotVelThresholdPercent = 10,
	WorldStepMax = 30,
	InterpolationFramePositionThresholdMillionth = 5,
	TimestepArbiterHumanoidTurningVelThreshold = 1,
	SimOwnedNOUCountThresholdMillionth = 2147483647,
	GameNetPVHeaderLinearVelocityZeroCutoffExponent = -5000,
	NextGenReplicatorEnabledWrite4 = true,
	TimestepArbiterOmegaThou = 1073741823,
	MaxAcceptableUpdateDelay = 1,
	LargeReplicatorSerializeWrite4 = true,
}

local function applyDesyncFFlags()
	for name, value in pairs(desyncFFlags) do
		pcall(function()
			setfflag(tostring(name), tostring(value))
		end)
	end
end

local function respawnForDesync()
	local char = localPlayer.Character
	if not char then return end

	local hum = char:FindFirstChildWhichIsA("Humanoid")
	if hum then
		hum:ChangeState(Enum.HumanoidStateType.Dead)
	end

	char:ClearAllChildren()
	local temp = Instance.new("Model")
	temp.Parent = workspace
	localPlayer.Character = temp
	task.wait()
	localPlayer.Character = char
	temp:Destroy()
end

clearDesyncESP = function()
	if desyncServerConn then
		pcall(function()
			desyncServerConn:Disconnect()
		end)
		desyncServerConn = nil
	end
	if desyncESPFolder then
		pcall(function()
			desyncESPFolder:Destroy()
		end)
		desyncESPFolder = nil
	end
	desyncServerESPPart = nil
end

local function createDesyncESPPart()
	local part = Instance.new("Part")
	part.Size = Vector3.new(2, 5, 2)
	part.Anchored = true
	part.CanCollide = false
	part.Material = Enum.Material.Neon
	part.Color = Color3.fromRGB(0, 200, 255)
	part.Transparency = 0.25
	part.Parent = desyncESPFolder

	local highlight = Instance.new("Highlight")
	highlight.FillColor = part.Color
	highlight.OutlineColor = part.Color
	highlight.FillTransparency = 0.4
	highlight.Parent = part

	local bb = Instance.new("BillboardGui")
	bb.Size = UDim2.new(0, 130, 0, 30)
	bb.AlwaysOnTop = true
	bb.Adornee = part
	bb.Parent = part

	local txt = Instance.new("TextLabel")
	txt.Size = UDim2.new(1, 0, 1, 0)
	txt.BackgroundTransparency = 1
	txt.Text = ""
	txt.TextScaled = true
	txt.Font = Enum.Font.GothamBold
	txt.TextColor3 = part.Color
	txt.Parent = bb

	return part
end

local function trackDesyncServer(hrp: BasePart)
	local lastPos = hrp.Position
	desyncServerConn = hrp:GetPropertyChangedSignal("Position"):Connect(function()
		task.wait(0.15)
		if not desyncServerESPPart or not desyncServerESPPart.Parent then return end
		lastPos = hrp.Position
		desyncServerESPPart.CFrame = CFrame.new(lastPos)
	end)
	if desyncServerESPPart then
		desyncServerESPPart.CFrame = CFrame.new(lastPos)
	end
end

local function setDesyncServerESP()
	clearDesyncESP()
	desyncESPFolder = Instance.new("Folder")
	desyncESPFolder.Name = "XENT_DesyncESP"
	desyncESPFolder.Parent = workspace

	desyncServerESPPart = createDesyncESPPart()

	local char = localPlayer.Character
	if char then
		local hrp = char:FindFirstChild("HumanoidRootPart")
		if hrp and hrp:IsA("BasePart") then
			trackDesyncServer(hrp)
		end
	end
end

local desyncEnabled = false
local desyncEnabling = false

enableDesync = function()
	if desyncEnabled or desyncEnabling then return end
	desyncEnabling = true
	task.spawn(function()
		applyDesyncFFlags()
		respawnForDesync()
		task.wait(0.6)
		setDesyncServerESP()
		desyncEnabled = true
		desyncEnabling = false
	end)
end

-- Target positions and closest-target helper for teleporting method
local targetPositions = {
	Vector3.new(-481.88, -3.79, 138.02),
	Vector3.new(-481.75, -3.79, 89.18),
	Vector3.new(-481.82, -3.79, 30.95),
	Vector3.new(-481.75, -3.79, -17.79),
	Vector3.new(-481.80, -3.79, -76.06),
	Vector3.new(-481.72, -3.79, -124.70),
	Vector3.new(-337.45, -3.85, -124.72),
	Vector3.new(-337.37, -3.85, -76.07),
	Vector3.new(-337.46, -3.79, -17.72),
	Vector3.new(-337.41, -3.79, 30.92),
	Vector3.new(-337.32, -3.79, 89.02),
	Vector3.new(-337.27, -3.79, 137.90),
	Vector3.new(-337.45, -3.79, 196.29),
	Vector3.new(-337.37, -3.79, 244.91),
	Vector3.new(-481.72, -3.79, 196.21),
	Vector3.new(-481.76, -3.79, 244.92),
}

local function getClosestTargetCFrame(hrp: BasePart)
	local closest
	local bestDist = math.huge
	for _, v in ipairs(targetPositions) do
		local d = (hrp.Position - v).Magnitude
		if d < bestDist then
			bestDist = d
			closest = v
		end
	end
	if closest then
		return CFrame.new(closest)
	end
	return nil
end

-- Save Position logic
local function savePosition()
	if exited then return end
	local _, hrp = getCharacterAndHRP()
	if not hrp then return end

	local cframe = hrp.CFrame
	savedCFrame = cframe

	if markerPart then
		pcall(function()
			markerPart:Destroy()
		end)
		markerPart = nil
	end

	local part = Instance.new("Part")
	part.Name = "XENT_SemiTP_Marker"
	part.Shape = Enum.PartType.Ball
	part.Size = Vector3.new(1.6, 1.6, 1.6)
	part.Color = Color3.fromRGB(80, 150, 255)
	part.Material = Enum.Material.Neon
	part.Anchored = true
	part.CanCollide = false
	part.CFrame = cframe
	part.TopSurface = Enum.SurfaceType.Smooth
	part.BottomSurface = Enum.SurfaceType.Smooth
	part.Parent = workspace

	local glow = Instance.new("PointLight")
	glow.Color = part.Color
	glow.Range = 8
	glow.Brightness = 2
	glow.Parent = part

	-- Floating distance label
	local billboard = Instance.new("BillboardGui")
	billboard.Name = "XENT_SavedPos_Label"
	billboard.Size = UDim2.new(0, 160, 0, 32)
	billboard.StudsOffsetWorldSpace = Vector3.new(0, 2.2, 0)
	billboard.AlwaysOnTop = true
	billboard.Adornee = part
	billboard.Parent = part

	local label = Instance.new("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UDim2.new(1, 0, 1, 0)
	label.Font = Enum.Font.GothamSemibold
	label.TextScaled = true
	label.TextColor3 = Color3.fromRGB(220, 230, 255)
	label.TextStrokeTransparency = 0.3
	label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
	label.Parent = billboard

	local function updateLabel()
		local char, hrpCurrent = getCharacterAndHRP()
		if not char or not hrpCurrent then return end
		local distance = (hrpCurrent.Position - part.Position).Magnitude
		local meters = math.floor(distance + 0.5)
		label.Text = string.format("SAVED POSTION [%dM]", meters)
	end

	-- Set initial text immediately so it never shows the default "Label"
	updateLabel()

	markerPart = part
	rebuildBeam()

	task.spawn(function()
		while not exited and markerPart == part and part.Parent do
			updateLabel()
			task.wait(0.1)
		end
	end)
end

saveButton.MouseButton1Click:Connect(savePosition)

-- SEMI_TP toggle
local function updateSemiVisual()
	if semiEnabled then
		semiButton.Text = "SEMI_TP : ON"
		semiButton.BackgroundColor3 = semiOnColor
	else
		semiButton.Text = "SEMI_TP : OFF"
		semiButton.BackgroundColor3 = semiOffColor
	end
end

local function toggleSemi()
	if exited then return end
	semiEnabled = not semiEnabled
	if semiEnabled then
		enableDesync()
	end
	updateSemiVisual()
end

semiButton.MouseButton1Click:Connect(toggleSemi)

-- Animation + teleport logic
local function playSpecialAnimation(humanoid)
	-- Instead of playing an Animation asset, instantly pose the arms and
	-- hard-block any other animations for 10 seconds.
	local character = humanoid.Parent
	if not character then return end

	-- Rotate both shoulders 90 degrees (R15 shoulders live on torso, so search by name)
	local modifiedJoints = {}
	local function poseShoulder(jointName, angleDeg)
		local joint = character:FindFirstChild(jointName, true)
		if not joint or not joint:IsA("Motor6D") then return end
		modifiedJoints[#modifiedJoints+1] = {joint = joint, c0 = joint.C0}
		joint.C0 = joint.C0 * CFrame.Angles(0, 0, math.rad(angleDeg))
	end

	poseShoulder("RightShoulder", 90)
	poseShoulder("LeftShoulder", -90)

	-- Block any animations from playing during the next 10 seconds
	local blockerConn
	blockerConn = humanoid.AnimationPlayed:Connect(function(newTrack)
		pcall(function()
			newTrack:Stop()
		end)
	end)

	task.delay(10, function()
		-- Restore original shoulder C0 values
		for _, info in ipairs(modifiedJoints) do
			local joint = info.joint
			if joint then
				pcall(function()
					joint.C0 = info.c0
				end)
			end
		end

		if blockerConn then
			pcall(function()
				blockerConn:Disconnect()
			end)
			blockerConn = nil
		end

		-- Nudge default Animate script so normal animations resume
		local charNow = humanoid.Parent
		if charNow then
			local animate = charNow:FindFirstChild("Animate")
			if animate and (animate:IsA("LocalScript") or animate:IsA("Script")) then
				pcall(function()
					animate.Disabled = true
					animate.Disabled = false
				end)
			end
		end
	end)
end

local function stopAllAnimations(humanoid)
	for _, track in ipairs(humanoid:GetPlayingAnimationTracks()) do
		pcall(function()
			track:Stop()
		end)
	end
end

local function startSemiAnimation()
	if exited or not semiEnabled then return end

	local char, hrp, humanoid = getCharacterAndHRP()
	if not char or not hrp or not humanoid then return end

	stopAllAnimations(humanoid)
	playSpecialAnimation(humanoid)
end

local function teleportToSaved()
	if exited or not semiEnabled then return end
	if not savedCFrame then return end

	local char, hrp, humanoid = getCharacterAndHRP()
	if not char or not hrp or not humanoid then return end

	local pos1 = savedCFrame
	local pos2 = getClosestTargetCFrame(hrp)

	task.spawn(function()
		pcall(function()
			if pos1 then
				hrp.CFrame = pos1
			end
			if pos2 then
				task.wait(0.05)
				hrp.CFrame = pos2
			end
		end)
	end)
end

-- Proximity prompt filters
local function containsSteal(text)
	if not text or text == "" then
		return false
	end
	text = string.lower(text)
	return string.find(text, "steal", 1, true) ~= nil
end

local function isStealPrompt(prompt: ProximityPrompt)
	return containsSteal(prompt.ObjectText) or containsSteal(prompt.ActionText)
end

local function onPromptHoldBegan(prompt: ProximityPrompt, player: Player)
	if exited then return end
	if not semiEnabled then return end
	if not savedCFrame then return end
	if not isStealPrompt(prompt) then return end

	activeHolds[prompt] = true

	-- Bind to this prompt's Triggered event once so we can teleport exactly when it's done
	if not promptTriggeredBound[prompt] then
		promptTriggeredBound[prompt] = true
		local conn = prompt.Triggered:Connect(function(triggerPlayer)
			if exited then return end
			if not semiEnabled then return end
			if not savedCFrame then return end
			if not isStealPrompt(prompt) then return end
			if triggerPlayer and triggerPlayer ~= localPlayer then return end

			task.spawn(function()
				if exited then return end
				teleportToSaved()
			end)
		end)
		addConnection(conn)
	end

	local holdDuration = prompt.HoldDuration or 0
	local waitTime = math.max(holdDuration - 0.1, 0)

	task.spawn(function()
		if waitTime > 0 then
			task.wait(waitTime)
		end
		if exited then return end
		if semiEnabled and activeHolds[prompt] and savedCFrame then
			startSemiAnimation()
		end
	end)
end

local function onPromptHoldEnded(prompt: ProximityPrompt, player: Player)
	activeHolds[prompt] = nil
end

addConnection(ProximityPromptService.PromptButtonHoldBegan:Connect(onPromptHoldBegan))
addConnection(ProximityPromptService.PromptButtonHoldEnded:Connect(onPromptHoldEnded))

-- AUTO GRAB: automatically fire non-Steal prompts when enabled
addConnection(ProximityPromptService.PromptShown:Connect(function(prompt, inputType)
	if exited then return end
	if not autoGrabEnabled then return end
	-- Do not interfere with SEMI_TP "Steal" prompts
	if isStealPrompt(prompt) then return end

	pcall(function()
		ProximityPromptService:FirePrompt(prompt, localPlayer)
	end)
end))

-- Exit button behavior
exitButton.MouseButton1Click:Connect(function()
	if exited then return end
	cleanup()
	pcall(function()
		screenGui:Destroy()
	end)
end)

-- Start with visuals synced
updateSemiVisual()
